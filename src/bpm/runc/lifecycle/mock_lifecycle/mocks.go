// Copyright (C) 2020-Present CloudFoundry.org Foundation, Inc. All rights reserved.
//
// This program and the accompanying materials are made available under
// the terms of the under the Apache License, Version 2.0 (the "License‚Äù);
// you may not use this file except in compliance with the License.
//
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.

// Code generated by MockGen. DO NOT EDIT.
// Source: bpm/runc/lifecycle/lifecycle.go

// Package mock_lifecycle is a generated GoMock package.
package mock_lifecycle

import (
	config "bpm/config"
	client "bpm/runc/client"
	io "io"
	os "os"
	exec "os/exec"
	reflect "reflect"

	lager "code.cloudfoundry.org/lager/v3"
	gomock "github.com/golang/mock/gomock"
	specs_go "github.com/opencontainers/runtime-spec/specs-go"
)

// MockUserFinder is a mock of UserFinder interface.
type MockUserFinder struct {
	ctrl     *gomock.Controller
	recorder *MockUserFinderMockRecorder
}

// MockUserFinderMockRecorder is the mock recorder for MockUserFinder.
type MockUserFinderMockRecorder struct {
	mock *MockUserFinder
}

// NewMockUserFinder creates a new mock instance.
func NewMockUserFinder(ctrl *gomock.Controller) *MockUserFinder {
	mock := &MockUserFinder{ctrl: ctrl}
	mock.recorder = &MockUserFinderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserFinder) EXPECT() *MockUserFinderMockRecorder {
	return m.recorder
}

// Lookup mocks base method.
func (m *MockUserFinder) Lookup(username string) (specs_go.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lookup", username)
	ret0, _ := ret[0].(specs_go.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lookup indicates an expected call of Lookup.
func (mr *MockUserFinderMockRecorder) Lookup(username interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lookup", reflect.TypeOf((*MockUserFinder)(nil).Lookup), username)
}

// MockCommandRunner is a mock of CommandRunner interface.
type MockCommandRunner struct {
	ctrl     *gomock.Controller
	recorder *MockCommandRunnerMockRecorder
}

// MockCommandRunnerMockRecorder is the mock recorder for MockCommandRunner.
type MockCommandRunnerMockRecorder struct {
	mock *MockCommandRunner
}

// NewMockCommandRunner creates a new mock instance.
func NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner {
	mock := &MockCommandRunner{ctrl: ctrl}
	mock.recorder = &MockCommandRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockCommandRunner) Run(arg0 *exec.Cmd) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockCommandRunnerMockRecorder) Run(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockCommandRunner)(nil).Run), arg0)
}

// MockRuncAdapter is a mock of RuncAdapter interface.
type MockRuncAdapter struct {
	ctrl     *gomock.Controller
	recorder *MockRuncAdapterMockRecorder
}

// MockRuncAdapterMockRecorder is the mock recorder for MockRuncAdapter.
type MockRuncAdapterMockRecorder struct {
	mock *MockRuncAdapter
}

// NewMockRuncAdapter creates a new mock instance.
func NewMockRuncAdapter(ctrl *gomock.Controller) *MockRuncAdapter {
	mock := &MockRuncAdapter{ctrl: ctrl}
	mock.recorder = &MockRuncAdapterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuncAdapter) EXPECT() *MockRuncAdapterMockRecorder {
	return m.recorder
}

// BuildSpec mocks base method.
func (m *MockRuncAdapter) BuildSpec(logger lager.Logger, bpmCfg *config.BPMConfig, procCfg *config.ProcessConfig, user specs_go.User) (specs_go.Spec, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildSpec", logger, bpmCfg, procCfg, user)
	ret0, _ := ret[0].(specs_go.Spec)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildSpec indicates an expected call of BuildSpec.
func (mr *MockRuncAdapterMockRecorder) BuildSpec(logger, bpmCfg, procCfg, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildSpec", reflect.TypeOf((*MockRuncAdapter)(nil).BuildSpec), logger, bpmCfg, procCfg, user)
}

// CreateJobPrerequisites mocks base method.
func (m *MockRuncAdapter) CreateJobPrerequisites(bpmCfg *config.BPMConfig, procCfg *config.ProcessConfig, user specs_go.User) (*os.File, *os.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateJobPrerequisites", bpmCfg, procCfg, user)
	ret0, _ := ret[0].(*os.File)
	ret1, _ := ret[1].(*os.File)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateJobPrerequisites indicates an expected call of CreateJobPrerequisites.
func (mr *MockRuncAdapterMockRecorder) CreateJobPrerequisites(bpmCfg, procCfg, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateJobPrerequisites", reflect.TypeOf((*MockRuncAdapter)(nil).CreateJobPrerequisites), bpmCfg, procCfg, user)
}

// MockRuncClient is a mock of RuncClient interface.
type MockRuncClient struct {
	ctrl     *gomock.Controller
	recorder *MockRuncClientMockRecorder
}

// MockRuncClientMockRecorder is the mock recorder for MockRuncClient.
type MockRuncClientMockRecorder struct {
	mock *MockRuncClient
}

// NewMockRuncClient creates a new mock instance.
func NewMockRuncClient(ctrl *gomock.Controller) *MockRuncClient {
	mock := &MockRuncClient{ctrl: ctrl}
	mock.recorder = &MockRuncClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRuncClient) EXPECT() *MockRuncClientMockRecorder {
	return m.recorder
}

// ContainerState mocks base method.
func (m *MockRuncClient) ContainerState(containerID string) (*specs_go.State, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ContainerState", containerID)
	ret0, _ := ret[0].(*specs_go.State)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ContainerState indicates an expected call of ContainerState.
func (mr *MockRuncClientMockRecorder) ContainerState(containerID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ContainerState", reflect.TypeOf((*MockRuncClient)(nil).ContainerState), containerID)
}

// CreateBundle mocks base method.
func (m *MockRuncClient) CreateBundle(bundlePath string, jobSpec specs_go.Spec, user specs_go.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateBundle", bundlePath, jobSpec, user)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateBundle indicates an expected call of CreateBundle.
func (mr *MockRuncClientMockRecorder) CreateBundle(bundlePath, jobSpec, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBundle", reflect.TypeOf((*MockRuncClient)(nil).CreateBundle), bundlePath, jobSpec, user)
}

// DeleteContainer mocks base method.
func (m *MockRuncClient) DeleteContainer(containerID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteContainer", containerID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteContainer indicates an expected call of DeleteContainer.
func (mr *MockRuncClientMockRecorder) DeleteContainer(containerID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteContainer", reflect.TypeOf((*MockRuncClient)(nil).DeleteContainer), containerID)
}

// DestroyBundle mocks base method.
func (m *MockRuncClient) DestroyBundle(bundlePath string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DestroyBundle", bundlePath)
	ret0, _ := ret[0].(error)
	return ret0
}

// DestroyBundle indicates an expected call of DestroyBundle.
func (mr *MockRuncClientMockRecorder) DestroyBundle(bundlePath interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DestroyBundle", reflect.TypeOf((*MockRuncClient)(nil).DestroyBundle), bundlePath)
}

// Exec mocks base method.
func (m *MockRuncClient) Exec(containerID, command string, stdin io.Reader, stdout, stderr io.Writer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", containerID, command, stdin, stdout, stderr)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockRuncClientMockRecorder) Exec(containerID, command, stdin, stdout, stderr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRuncClient)(nil).Exec), containerID, command, stdin, stdout, stderr)
}

// ListContainers mocks base method.
func (m *MockRuncClient) ListContainers() ([]client.ContainerState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListContainers")
	ret0, _ := ret[0].([]client.ContainerState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListContainers indicates an expected call of ListContainers.
func (mr *MockRuncClientMockRecorder) ListContainers() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListContainers", reflect.TypeOf((*MockRuncClient)(nil).ListContainers))
}

// RunContainer mocks base method.
func (m *MockRuncClient) RunContainer(pidFilePath, bundlePath, containerID string, detach bool, stdout, stderr io.Writer) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunContainer", pidFilePath, bundlePath, containerID, detach, stdout, stderr)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunContainer indicates an expected call of RunContainer.
func (mr *MockRuncClientMockRecorder) RunContainer(pidFilePath, bundlePath, containerID, detach, stdout, stderr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunContainer", reflect.TypeOf((*MockRuncClient)(nil).RunContainer), pidFilePath, bundlePath, containerID, detach, stdout, stderr)
}

// SignalContainer mocks base method.
func (m *MockRuncClient) SignalContainer(containerID string, signal client.Signal) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SignalContainer", containerID, signal)
	ret0, _ := ret[0].(error)
	return ret0
}

// SignalContainer indicates an expected call of SignalContainer.
func (mr *MockRuncClientMockRecorder) SignalContainer(containerID, signal interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SignalContainer", reflect.TypeOf((*MockRuncClient)(nil).SignalContainer), containerID, signal)
}
